@page "/{*fileName:nonfile}"
@page "/"

@using System.Diagnostics.CodeAnalysis
@using MyLittleContentEngine.Models
@using MyLittleContentEngine.Services.Content
@using Microsoft.AspNetCore.Components.Sections
@inject ContentEngineOptions ContentEngineOptions
@inject IMarkdownContentService<DocsFrontMatter> MarkdownContentService

@if (IsLoaded)
{
    <PageTitle>@ContentEngineOptions.SiteTitle - @_post.FrontMatter.Title</PageTitle>
    <article>
        <header>
            <h1 class="font-display text-2xl lg:text-4xl font-bold tracking-tight text-base-900 dark:text-base-50"> @_post.FrontMatter.Title</h1>
        </header>

        <div
            class="prose dark:prose-invert max-w-full prose-sm md:prose-base min-w-0 prose-headings:scroll-m-28 prose-headings:font-display prose-headings:text-base-900 dark:prose-headings:text-base-50">
            @((MarkupString)_postContent)
        </div>

        @if (_previousPage != null || _nextPage != null)
        {
            <div class="flex my-4 border-t border-base-200 dark:border-base-700 pt-4 lg:pt-8 lg:my-8">
            @if (_previousPage != null)
            {
                @NextPreviousButton(_previousPage, false)
            }
            @if (_nextPage != null)
            {
                @NextPreviousButton(_nextPage, true)
            }
            </div>
        }
    </article>
}
else
{
    <PageTitle>@ContentEngineOptions.SiteTitle</PageTitle>
    <p>Not found</p>
}

<SectionContent SectionName="sidebar">
    @if (IsLoaded)
    {
        <OutlineNavigation
            Outline="@_outline"
            BaseUrl="@_post.NavigateUrl"/>
    }
</SectionContent>

@code {
    private MarkdownContentPage<DocsFrontMatter>? _post;
    private string? _postContent;
    private OutlineEntry[]? _outline;
    private MarkdownContentPage<DocsFrontMatter>? _previousPage;
    private MarkdownContentPage<DocsFrontMatter>? _nextPage;

    [MemberNotNull(nameof(_postContent))]
    [MemberNotNull(nameof(_outline))]
    [MemberNotNull(nameof(_post))]
    bool IsLoaded { get; set; }

    [Parameter] public required string FileName { get; init; } = string.Empty;

    private RenderFragment NextPreviousButton(MarkdownContentPage<DocsFrontMatter> p, bool isNext) => 
        @<div class="flex flex-col items-@(isNext ? "end" : "start") @(isNext ? "ml-auto" : "") gap-3">
        <a class="inline-flex gap-0.5 justify-center overflow-hidden text-sm font-medium font-display transition rounded-xl bg-base-200 pt-2 pb-1.5 px-3.5  hover:bg-base-300/75 dark:bg-base-800/40 text-base-800 dark:text-base-400 ring-1 dark:ring-inset ring-base-300/75 dark:ring-base-800 dark:hover:bg-base-800 dark:hover:text-base-300"
           aria-label="@(isNext ? "Next" : "Previous"): @p.FrontMatter.Title" href="@p.NavigateUrl">
            @(isNext ? "Next" : "")
            <svg viewBox="0 0 20 20" fill="none" aria-hidden="true" class="mt-0.5 h-5 w-5 @(isNext ? "-mr-1" : "-ml-1") @(isNext ? "" : "rotate-180")">
                <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                      d="m11.5 6.5 3 3.5m0 0-3 3.5m3-3.5h-9"></path>
            </svg>
            @(isNext ? "" : "Previous")
        </a>
        <a tabindex="-1" aria-hidden="true"
           class="text-base font-semibold text-base-700 transition hover:text-base-600 dark:text-base-400 dark:hover:text-base-300"
           href="@p.NavigateUrl">
            @p.FrontMatter.Title</a>
    </div>;
    
    protected override async Task OnInitializedAsync()
    {
        var fileName = FileName;
        if (string.IsNullOrWhiteSpace(fileName))
        {
            fileName = "index";
        }

        var page = await MarkdownContentService.GetRenderedContentPageByUrlOrDefault(fileName);
        if (page == null)
        {
            return;
        }

        _outline = page.Value.Page.Outline;
        _post = page.Value.Page;
        _postContent = page.Value.HtmlContent;

        // Get all pages and sort by Order to find previous/next
        await SetupNavigationPages();

        IsLoaded = true;
    }

    private async Task SetupNavigationPages()
    {
        if (_post == null) return;

        // Get all content pages and sort by Order
        var allPages = await MarkdownContentService.GetAllContentPagesAsync();
        var sortedPages = allPages
            .Where(p => !p.FrontMatter.IsDraft) // Only include non-draft pages
            .OrderBy(p => p.FrontMatter.Order)
            .ThenBy(p => p.FrontMatter.Title) // Secondary sort by title for stability
            .ToList();

        // Find the current page index
        var currentIndex = -1;
        for (int i = 0; i < sortedPages.Count; i++)
        {
            if (sortedPages[i].NavigateUrl == _post.NavigateUrl)
            {
                currentIndex = i;
                break;
            }
        }

        if (currentIndex == -1) return; // Current page not found in sorted list

        // Set previous page (if not at the beginning)
        if (currentIndex > 0)
        {
            _previousPage = sortedPages[currentIndex - 1];
        }

        // Set next page (if not at the end)
        if (currentIndex < sortedPages.Count - 1)
        {
            _nextPage = sortedPages[currentIndex + 1];
        }
    }

}
